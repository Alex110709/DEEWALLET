/**
 * DEE WALLET - Wallet Detail Screen Implementation
 */

#include "WalletDetailScreen.h"
#include "SendTransactionDialog.h"
#include "QRCodeDialog.h"
#include "AddressBookDialog.h"
#include "../chains/BitcoinAdapter.h"
#include "../chains/EthereumAdapter.h"
#include "../chains/TronAdapter.h"
#include "../chains/SolanaAdapter.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QScrollArea>
#include <QMessageBox>
#include <QApplication>
#include <QClipboard>

WalletDetailScreen::WalletDetailScreen(const QString &mnemonic, QWidget *parent)
    : QWidget(parent)
    , mnemonic(mnemonic)
    , chainListContainer(new QWidget(this))
    , chainListLayout(new QVBoxLayout(chainListContainer))
    , refreshButton(new QPushButton("새로고침", this))
    , backButton(new QPushButton("← 뒤로", this))
{
    setupUI();
    loadWallet();
    refreshBalances();
}

void WalletDetailScreen::setupUI()
{
    auto *mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(20, 20, 20, 20);
    mainLayout->setSpacing(20);

    // Top bar with back button
    auto *topBar = new QHBoxLayout();
    backButton->setObjectName("secondaryButton");
    backButton->setMaximumWidth(100);
    topBar->addWidget(backButton);
    topBar->addStretch();

    auto *titleLabel = new QLabel("DEE WALLET", this);
    titleLabel->setStyleSheet("font-size: 24px; font-weight: bold;");
    topBar->addWidget(titleLabel);
    topBar->addStretch();

    mainLayout->addLayout(topBar);

    // Action buttons
    refreshButton->setMinimumHeight(45);
    refreshButton->setStyleSheet(R"(
        QPushButton {
            background-color: #4a9eff;
            border: none;
            border-radius: 8px;
            padding: 12px;
            color: #ffffff;
            font-size: 14px;
            font-weight: bold;
        }
        QPushButton:hover {
            background-color: #5aafff;
        }
        QPushButton:pressed {
            background-color: #3a8eef;
        }
    )");

    mainLayout->addWidget(refreshButton);

    // Chain list title
    auto *listTitle = new QLabel("자산 목록", this);
    listTitle->setStyleSheet("font-size: 18px; font-weight: bold; color: #ffffff; margin-top: 10px;");
    mainLayout->addWidget(listTitle);

    // Chain list container with scroll
    auto *scrollArea = new QScrollArea(this);
    scrollArea->setWidgetResizable(true);
    scrollArea->setWidget(chainListContainer);
    scrollArea->setStyleSheet(R"(
        QScrollArea {
            border: none;
            background-color: transparent;
        }
    )");
    
    chainListLayout->setSpacing(12);
    chainListLayout->setAlignment(Qt::AlignTop);
    
    mainLayout->addWidget(scrollArea, 1);

    // Initialize chain data
    chains = {
        {"Bitcoin", "BTC", "", "0.0", nullptr, nullptr},
        {"Ethereum", "ETH", "", "0.0", nullptr, nullptr},
        {"Tron", "TRX", "", "0.0", nullptr, nullptr},
        {"Solana", "SOL", "", "0.0", nullptr, nullptr},
        {"Litecoin", "LTC", "", "0.0", nullptr, nullptr},
        {"Dogecoin", "DOGE", "", "0.0", nullptr, nullptr}
    };

    // Create card for each chain
    for (int i = 0; i < chains.size(); ++i) {
        auto *chainCard = new QWidget(chainListContainer);
        chainCard->setMinimumHeight(100);
        chainCard->setStyleSheet(R"(
            QWidget {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 #3a3a3a, stop:1 #2a2a2a);
                border: 2px solid #4a4a4a;
                border-radius: 12px;
            }
        )");

        auto *cardLayout = new QHBoxLayout(chainCard);
        cardLayout->setContentsMargins(20, 15, 20, 15);
        cardLayout->setSpacing(15);

        // Left side: Chain info
        auto *leftLayout = new QVBoxLayout();
        leftLayout->setSpacing(5);

        auto *chainNameLabel = new QLabel(chains[i].name + " (" + chains[i].symbol + ")", chainCard);
        chainNameLabel->setStyleSheet("font-size: 18px; font-weight: bold; color: #ffffff;");

        auto *tapHintLabel = new QLabel("탭하여 주소 관리", chainCard);
        tapHintLabel->setStyleSheet("font-size: 11px; color: #666666;");

        leftLayout->addWidget(chainNameLabel);
        leftLayout->addWidget(tapHintLabel);
        leftLayout->addStretch();

        cardLayout->addLayout(leftLayout, 1);

        // Right side: Balance
        auto *rightLayout = new QVBoxLayout();
        rightLayout->setAlignment(Qt::AlignRight | Qt::AlignVCenter);

        auto *balanceLabel = new QLabel("0.0 " + chains[i].symbol, chainCard);
        balanceLabel->setStyleSheet("font-size: 20px; font-weight: bold; color: #4a9eff;");
        balanceLabel->setAlignment(Qt::AlignRight);

        rightLayout->addWidget(balanceLabel);

        cardLayout->addLayout(rightLayout);

        chains[i].cardWidget = chainCard;
        chains[i].balanceLabel = balanceLabel;

        chainListLayout->addWidget(chainCard);

        // Make card clickable
        chainCard->setProperty("clickable", true);
        chainCard->setProperty("chainIndex", i);
        chainCard->installEventFilter(this);
    }
    
    chainListLayout->addStretch();

    // Connect buttons
    connect(backButton, &QPushButton::clicked, this, &WalletDetailScreen::onBackClicked);
    connect(refreshButton, &QPushButton::clicked, this, &WalletDetailScreen::onRefreshBalances);
    connect(sendButton, &QPushButton::clicked, this, &WalletDetailScreen::onSendTransaction);
    connect(receiveButton, &QPushButton::clicked, this, &WalletDetailScreen::onReceive);
}

void WalletDetailScreen::loadWallet()
{
    if (!wallet.restoreFromMnemonic(mnemonic)) {
        QMessageBox::critical(this, "오류", "복구 문구에서 지갑을 복원하지 못했습니다.");
        return;
    }

    // Generate addresses for all chains (index 0 only, user can add more)
    chains[0].address = wallet.deriveAddress("BTC", 0);  // Bitcoin
    chains[1].address = wallet.deriveAddress("ETH", 0);  // Ethereum
    chains[2].address = wallet.deriveAddress("TRX", 0);  // Tron
    chains[3].address = wallet.deriveAddress("SOL", 0);  // Solana
    chains[4].address = wallet.deriveAddress("LTC", 0);  // Litecoin
    chains[5].address = wallet.deriveAddress("DOGE", 0); // Dogecoin
}

void WalletDetailScreen::refreshBalances()
{
    // Fetch real balances from blockchain APIs
    for (int i = 0; i < chains.size(); ++i) {
        QString balance = "0.0";

        try {
            if (i == 0) {
                // Bitcoin
                BitcoinAdapter adapter("", false);
                balance = adapter.getBalance(chains[i].address);
            } else if (i == 1) {
                // Ethereum
                EthereumAdapter adapter("");
                balance = adapter.getBalance(chains[i].address);
            } else if (i == 2) {
                // Tron
                TronAdapter adapter("");
                balance = adapter.getBalance(chains[i].address);
            } else if (i == 3) {
                // Solana
                SolanaAdapter adapter("");
                balance = adapter.getBalance(chains[i].address);
            } else if (i == 4) {
                // Litecoin - use Bitcoin adapter (same format)
                BitcoinAdapter adapter("", false);
                balance = adapter.getBalance(chains[i].address);
            } else if (i == 5) {
                // Dogecoin - use Bitcoin adapter (same format)
                BitcoinAdapter adapter("", false);
                balance = adapter.getBalance(chains[i].address);
            }

            chains[i].balance = balance;
            if (chains[i].balanceLabel) {
                chains[i].balanceLabel->setText(balance + " " + chains[i].symbol);
            }
        } catch (...) {
            // If balance query fails, keep showing 0.0
            chains[i].balance = "0.0";
            if (chains[i].balanceLabel) {
                chains[i].balanceLabel->setText("0.0 " + chains[i].symbol);
            }
        }
    }
}

void WalletDetailScreen::updateChainCard(int index, const QString &chain, const QString &address, const QString &balance)
{
    if (index >= 0 && index < chains.size()) {
        chains[index].address = address;
        chains[index].balance = balance;

        if (chains[index].balanceLabel) {
            chains[index].balanceLabel->setText(balance + " " + chains[index].symbol);
        }
    }
}

void WalletDetailScreen::onRefreshBalances()
{
    // Show loading indicator
    refreshButton->setEnabled(false);
    refreshButton->setText("새로고침 중...");

    refreshBalances();

    refreshButton->setEnabled(true);
    refreshButton->setText("새로고침");

    QString message = "잔액을 갱신했습니다!\n\n";
    for (int i = 0; i < chains.size(); ++i) {
        message += chains[i].name + ": " + chains[i].balance + " " + chains[i].symbol + "\n";
    }
    
    QMessageBox::information(this, "완료", message);
}

void WalletDetailScreen::onSendTransaction()
{
    // Show dialog to select chain first
    QMessageBox msgBox(this);
    msgBox.setWindowTitle("체인 선택");
    msgBox.setText("전송할 체인을 선택하세요:");
    
    QPushButton *btcButton = msgBox.addButton("Bitcoin (BTC)", QMessageBox::ActionRole);
    QPushButton *ethButton = msgBox.addButton("Ethereum (ETH)", QMessageBox::ActionRole);
    QPushButton *trxButton = msgBox.addButton("Tron (TRX)", QMessageBox::ActionRole);
    QPushButton *solButton = msgBox.addButton("Solana (SOL)", QMessageBox::ActionRole);
    QPushButton *ltcButton = msgBox.addButton("Litecoin (LTC)", QMessageBox::ActionRole);
    QPushButton *dogeButton = msgBox.addButton("Dogecoin (DOGE)", QMessageBox::ActionRole);
    msgBox.addButton(QMessageBox::Cancel);
    
    msgBox.exec();
    
    int selectedChain = -1;
    if (msgBox.clickedButton() == btcButton) selectedChain = 0;
    else if (msgBox.clickedButton() == ethButton) selectedChain = 1;
    else if (msgBox.clickedButton() == trxButton) selectedChain = 2;
    else if (msgBox.clickedButton() == solButton) selectedChain = 3;
    else if (msgBox.clickedButton() == ltcButton) selectedChain = 4;
    else if (msgBox.clickedButton() == dogeButton) selectedChain = 5;
    
    if (selectedChain >= 0 && selectedChain < chains.size()) {
        QString chainType = chains[selectedChain].name;
        QString fromAddress = chains[selectedChain].address;

        SendTransactionDialog dialog(chainType, fromAddress, mnemonic, this);
        if (dialog.exec() == QDialog::Accepted) {
            // Transaction sent, refresh balances
            refreshBalances();
        }
    }
}

void WalletDetailScreen::onReceive()
{
    // Show dialog to select chain
    QMessageBox msgBox(this);
    msgBox.setWindowTitle("체인 선택");
    msgBox.setText("받을 체인을 선택하세요:");
    
    QPushButton *btcButton = msgBox.addButton("Bitcoin (BTC)", QMessageBox::ActionRole);
    QPushButton *ethButton = msgBox.addButton("Ethereum (ETH)", QMessageBox::ActionRole);
    QPushButton *trxButton = msgBox.addButton("Tron (TRX)", QMessageBox::ActionRole);
    QPushButton *solButton = msgBox.addButton("Solana (SOL)", QMessageBox::ActionRole);
    QPushButton *ltcButton = msgBox.addButton("Litecoin (LTC)", QMessageBox::ActionRole);
    QPushButton *dogeButton = msgBox.addButton("Dogecoin (DOGE)", QMessageBox::ActionRole);
    msgBox.addButton(QMessageBox::Cancel);
    
    msgBox.exec();
    
    int selectedChain = -1;
    if (msgBox.clickedButton() == btcButton) selectedChain = 0;
    else if (msgBox.clickedButton() == ethButton) selectedChain = 1;
    else if (msgBox.clickedButton() == trxButton) selectedChain = 2;
    else if (msgBox.clickedButton() == solButton) selectedChain = 3;
    else if (msgBox.clickedButton() == ltcButton) selectedChain = 4;
    else if (msgBox.clickedButton() == dogeButton) selectedChain = 5;
    
    if (selectedChain >= 0 && selectedChain < chains.size()) {
        QString address = chains[selectedChain].address;
        QString chainName = chains[selectedChain].name;

        QRCodeDialog dialog(address, chainName, this);
        dialog.exec();
    }
}

void WalletDetailScreen::onCopyAddress(const QString &address)
{
    QClipboard *clipboard = QApplication::clipboard();
    clipboard->setText(address);

    QMessageBox::information(this, "복사 완료",
        "주소가 클립보드에 복사되었습니다:\n\n" + address);
}


void WalletDetailScreen::onBackClicked()
{
    emit backToWelcome();
}
bool WalletDetailScreen::eventFilter(QObject *obj, QEvent *event)
{
    QWidget *widget = qobject_cast<QWidget*>(obj);
    
    if (widget && widget->property("clickable").toBool()) {
        if (event->type() == QEvent::MouseButtonPress) {
            int chainIndex = widget->property("chainIndex").toInt();
            onChainCardClicked(chainIndex);
            return true;
        }
    }
    
    return QWidget::eventFilter(obj, event);
}

void WalletDetailScreen::onChainCardClicked(int chainIndex)
{
    if (chainIndex < 0 || chainIndex >= chains.size()) {
        return;
    }
    
    // Emit signal to navigate to ChainDetailScreen
    emit chainClicked(chains[chainIndex].name, 
                     chains[chainIndex].symbol, 
                     mnemonic);
}
